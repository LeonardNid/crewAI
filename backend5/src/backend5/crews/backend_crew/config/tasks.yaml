# ──────────────────────────────────────────────────────────────────────────────
#  REQUIREMENTS ANALYST TASKS
# ──────────────────────────────────────────────────────────────────────────────

features_extraction_task:
  description: >
    Last result: {feature_checklist}
    Defects detected by verification_agent: {defects}
    Customer thoughts: {customer}

    1. Identify **all distinct user-facing features / use-cases** implied
       or explicitly mentioned (e.g. “list all players of a team”,
       “filter persons by country”).
    2. Write a numbered Markdown checklist - one line per feature.
    3. No code, no SQL - just plain prose that a later agent can read.
  expected_output: >
    A Markdown file named "feature_checklist.md" containing the list.
  agent: requirements_analyst
  output_file: Output/backendCrew/feature_checklist.md


entities_extraction_task:
  description: >
    Last result: {entity_overview}
    Defects detected by verification_agent: {defects}
    Customer thoughts: {customer}

    1. List **all entities (domain objects)** the product must store.
    2. For each entity add a bullet with:
         - brief description
         - obvious attributes mentioned
         - tentative relations (e.g. “Team 1-n Player”).
    3. Use Markdown; no code.
  expected_output: >
    A Markdown file named "entity_overview.md" with the catalogue.
  agent: requirements_analyst
  output_file: Output/backendCrew/entity_overview.md

# ──────────────────────────────────────────────────────────────────────────────
#  API PLANNER TASKS
# ──────────────────────────────────────────────────────────────────────────────

models_json_task:
  description: >
    Last result: {models_json}
    Defects detected by verification_agent: {defects}
    Produce `models_JSON.json` - a JSON object matching the Pydantic `ModelsPlan` schema:

      • `topic`        : string - the domain/topic name (e.g. "Bicycle Workshop").  
      • `models`       : array of model definitions, each with:
          - `name`         : CamelCase model name (e.g. "Frame")
          - `table`        : snake_case plural table name (e.g. "frames")
          - `columns`      : array of objects with:
              * `name`         : column name (e.g. "id")
              * `type`         : SQLAlchemy definition string  
                                 (e.g. `"db.Integer, primary_key=True"`)
              * `description`  : (optional) human-readable note
          - `relationships`: (optional) array of objects with:
              * `target_model` : related model name (e.g. "Brake")
              * `rel_type`     : relationship type  
                                 (`"one_to_many"`, `"many_to_many"`, etc.)
              * `fk_column`    : foreign key column name (e.g. "frame_id")
              * `backref`      : (optional) backref attribute name
    Ensure every entity and every relation from the input overview is represented.
    You may use the "data_object_lookup" tool to get a reference to some models.
    You can and should adapt the output of the tool to fit your requirements. 
  expected_output: >
    Pure JSON (no Markdown, no code), conforming exactly to the `ModelsPlan` schema.
  agent: api_planner
  context: [features_extraction_task, entities_extraction_task]
  output_file: Output/backendCrew/models.json


routes_json_task:
  description: >
    Last result: {routes_json}
    Defects detected by verification_agent: {defects}
    Produce `routes.json` - a JSON object matching the Pydantic `RoutesPlan` schema:

      • `topic`     : string - the same domain/topic name.  
      • `endpoints` : array of endpoint definitions, each with:
          - `path`       : Flask-style URL (e.g. `/frames`, `/frames/<int:id>`)
          - `methods`    : list of HTTP verbs (e.g. `["GET","POST"]`)
          - `model`      : associated model name (e.g. `"Frame"`)
          - `get_List`   : (optional) if GET method returns a list of objects
          - `json_body`  : (optional) object listing required keys for POST/PUT, else `null`
          - `description`: (optional) short human explanation
    The full set of endpoints **must enable every feature** in the checklist.
    Do not split different methods with the same path into separate entries.
    Use these specific paths for:
    1) Nested Resource? e.g.: /teams/<int:team_id>/players
    2) Search Endpoint? e.g.: /players/search/<string:name>
    3) Filter Endpoint? e.g.: /players/filter/country/<string:country>

  expected_output: >
    Pure JSON only. One JSON object conforming exactly to the `RoutesPlan` schema.
  agent: api_planner
  context: [features_extraction_task, entities_extraction_task,
            models_json_task]
  output_file: Output/backendCrew/routes.json


# ──────────────────────────────────────────────────────────────────────────────
#  VERIFICATION AGENT TASK
# ──────────────────────────────────────────────────────────────────────────────

verification_task:
  description: >
    Last defects: {defects}
    Customer thoughts: {customer}
    Your job is to verify the functionality of the generated JSON-Files by comparing
    the customer thoughts against the two JSON outputs:
      - models_JSON.json (the data models),
      - app_JSON.json (the defined endpoints and HTTP methods).
    But don't make up any new requirements the customer didn't mention.
    Focus on the **features** and **endpoints** the customer asked for.
    You don't need to check for safety features, security, or performance.
    Just check if the models and endpoints are complete.

    You must:
      1. Check whether **all required features** mentioned by the customer are
         actually supported by the models and endpoints.
      2. Ensure that each model includes **all necessary fields** and that
         the data types are correct (e.g., db.String for text, db.Integer for IDs).
      3. Check if the **relationships** between models (e.g. Team ↔ Player)
         are properly represented (e.g., foreign keys and backrefs).
      4. Check if the API includes **all CRUD endpoints** for each model:
         - POST, GET (list), GET (by ID), PUT, DELETE.
         - Include special endpoints too, e.g., "GET /players/country/<country>"

    You must return a JSON object of type `Verification`, like this:

    {
      "retry": true,
      "defects": [
        "Missing endpoint: GET /teams/<id>",
        "Player model has no 'position' field",
        "Foreign key team_id missing on Player",
        "No endpoint to filter players by country"
      ]
    }

  expected_output: >
    Return a valid JSON object matching the `Verification` schema:
    {
      "retry": <true/false>,
      "defects": [<list of strings, or empty>]
    }
  agent: verification_agent
  context: [features_extraction_task, entities_extraction_task, models_json_task, routes_json_task]
  output_file: Output/backendCrew/verification_result.json
