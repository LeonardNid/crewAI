# ──────────────────────────────────────────────────────────────────────────────
#  REQUIREMENTS ANALYST TASKS
# ──────────────────────────────────────────────────────────────────────────────

features_extraction_task:
  description: >
    Last result: {feature_checklist}
    Defects detected by verification_agent: {defects}
    Customer thoughts: {customer}

    1. Identify **all distinct user-facing features / use-cases** implied
       or explicitly mentioned (e.g. “list all players of a team”,
       “filter persons by country”).
    2. Write a numbered Markdown checklist - one line per feature.
    3. No code, no SQL - just plain prose that a later agent can read.
  expected_output: >
    A Markdown file named "feature_checklist.md" containing the list.
  agent: requirements_analyst
  output_file: Output/backendCrew/feature_checklist.md


entities_extraction_task:
  description: >
    Last result: {entity_overview}
    Defects detected by verification_agent: {defects}
    Customer thoughts: {customer}

    1. List **all entities (domain objects)** the product must store.
    2. For each entity add a bullet with:
         - brief description
         - obvious attributes mentioned
         - tentative relations (e.g. “Team 1-n Player”).
    3. Use Markdown; no code.
  expected_output: >
    A Markdown file named "entity_overview.md" with the catalogue.
  agent: requirements_analyst
  output_file: Output/backendCrew/entity_overview.md

# ──────────────────────────────────────────────────────────────────────────────
#  API PLANNER TASKS
# ──────────────────────────────────────────────────────────────────────────────

models_json_task:
  description: >
    Last result: {models_json}
    Defects detected by verification_agent: {defects}
    Produce `models_JSON.json` - a JSON object matching the Pydantic `ModelsPlan` schema:

      • `topic`        : string - the domain/topic name (e.g. "Bicycle Workshop").  
      • `models`       : array of model definitions, each with:
          - `name`         : CamelCase model name (e.g. "Frame")
          - `table`        : snake_case plural table name (e.g. "frames")
          - `columns`      : array of objects with:
              * `name`         : column name (e.g. "id")
              * `type`         : SQLAlchemy definition string  
                                 (e.g. `"db.Integer, primary_key=True"`)
              * `description`  : (optional) human-readable note
          - `relationships`: (optional) array of objects with:
              * `target_model` : related model name (e.g. "Brake")
              * `rel_type`     : relationship type  
                                 (`"one_to_many"`, `"many_to_many"`, etc.)
              * `fk_column`    : foreign key column name (e.g. "frame_id")
              * `backref`      : (optional) backref attribute name
    Ensure every entity and every relation from the input overview is represented.
    You may use the "data_object_lookup" tool to get a reference to some models.
    You can and should adapt the output of the tool to fit your requirements. 
  expected_output: >
    Pure JSON (no Markdown, no code), conforming exactly to the `ModelsPlan` schema.
  agent: api_planner
  context: [features_extraction_task, entities_extraction_task]
  output_file: Output/backendCrew/models.json


routes_json_task:
  description: >
    Last result: {routes_json}
    Defects detected by verification_agent: {defects}
    Produce `routes.json` - a JSON object matching the Pydantic `RoutesPlan` schema:

      • `topic`     : string - the same domain/topic name.  
      • `endpoints` : array of endpoint definitions, each with:
          - `path`       : Flask-style URL (e.g. `/frames`, `/frames/<int:id>`)
          - `methods`    : list of HTTP verbs (e.g. `["GET","POST"]`)
          - `model`      : associated model name (e.g. `"Frame"`)
          - `get_List`   : (optional) if GET method returns a list of objects
          - `json_body`  : (optional) object listing required keys for POST/PUT, else `null`
          - `description`: (optional) short human explanation
    The full set of endpoints **must enable every feature** in the checklist.
    Do not split different methods with the same path into separate entries.
    It is extremly important that you :
    1) Nested Resource? e.g.: /model1/<int:id>/model2
    2) Search Endpoint? e.g.: /model1/search/<string:name>

  expected_output: >
    Pure JSON only. One JSON object conforming exactly to the `RoutesPlan` schema.
  agent: api_planner
  context: [features_extraction_task, entities_extraction_task,
            models_json_task]
  output_file: Output/backendCrew/routes.json
