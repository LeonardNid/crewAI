# ──────────────────────────────────────────────────────────────────────────────
#  BRANCH VERIFIER TASK
# ──────────────────────────────────────────────────────────────────────────────

branch_verification_task:
  description: >
    This is the routes.json file:
    {routes_json}

    Your mission is to **carefully verify the behavior** of each endpoint branch in the API specification.

    1. For every element in the "endpoints" array:
         • Read the `description` and understand the expected behavior.
         • Validate the **body code** inside each branch (ignore function headers).

    2. If you find ANY mismatch between description and branch code:
         • You MUST invoke the tool **json_branch_update** during task execution (not in your text output).
         • You MUST build the correct "Action Input" payload and actually CALL the tool, not describe it.

    3. Tool Call Requirements:
         - All detected issues must be bundled into a single json_branch_update call.
         - Example payload structure:
         ```
         {
           "edits": [
             {
               "path": "/players/team/<int:team_id>",
               "method": "GET",
               "reason": "Mismatch between description and code behavior",
               "new_code": "Correct replacement code here"
             }
           ]
         }
         ```
         - Calling json_branch_update is mandatory if any fixes are needed.
         - If no fixes are needed, you do NOT call any tools.

    **CRITICAL RULES**:
      - Simply mentioning the json_branch_update tool is not enough: you MUST truly execute it.
      - Failure to actually call the tool properly = mission failure.

  expected_output: >
    - If corrections were needed: json_branch_update was invoked properly, and a Markdown summary was provided.
    - If no corrections were needed: no tool call, and a Markdown summary confirming no issues found.

  agent: branch_verifier
  output_file: Output/checkupCrew/refinement_Summary.json



# ──────────────────────────────────────────────────────────────────────────────
#  VERIFICATION AGENT TASK
# ──────────────────────────────────────────────────────────────────────────────

verification_task:
  description: >
    Feature checklist for the customer:
    {feature_checklist}

    models.json file:
    {models_json}

    routes.json file:
    {routes_json}


    Your job is to verify the functionality of the generated JSON-Files by comparing
    the feature checklist against the two JSON outputs:
      - models.json (the data models),
      - routes.json (the defined endpoints and HTTP methods).
    But don't make up any new requirements the customer didn't mention.
    Focus on the **features** and **endpoints** the customer asked for.
    You don't need to check for safety features, security, or performance.
    Just check for completeness.

    You must:
      1. Check whether **all required features** mentioned by the customer are
         actually supported by the models and endpoints.
      2. Ensure that each model includes **all necessary fields** and that
         the data types are correct (e.g., db.String for text, db.Integer for IDs).
      3. Check if the **relationships** between models (e.g. Team ↔ Player)
         are properly represented (e.g., foreign keys and backrefs).
      4. Check if the API includes **all CRUD endpoints** for each model:
         - POST, GET (list), GET (by ID), PUT, DELETE.
         - Include special endpoints too, e.g., "GET /players/country/<country>"
  expected_output: >
    Return a valid JSON object matching the `Verification` schema:
    {
      "retry": <true/false>,
      "defects": [<list of strings, or empty>]
    }
  agent: verification_agent
  output_file: Output/checkupCrew/verification_result.json
